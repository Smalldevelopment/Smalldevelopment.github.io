<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 类的基本使用]]></title>
    <url>%2F2018%2F04%2F26%2FSwift-%E5%85%AD-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[类的介绍 注意：当一个实例对象被创建好之后,必须保证里面所有的非可选属性都有值 // swift 中,类是可以不继承父类的,那它本身就是rootClassclass Person&#123;//方案一:var name : Stringinit()&#123;self.name = ""&#125;init(name:String)&#123;self.name = name&#125;//方案二:var name : String?//方案三:var name : String = ""//可以写属性和方法//属性:实例属性,类型属性//方法:实例方法,类型方法&#125;//类,默认情况下,不会生成逐一构造函数(目的:保证所有非可选属性有值)//默认情况下,不能保证,所有的非可选属性有值//当一个实例对象被创建好之后,必须保证里面所有的非可选属性都有值//方案一:在构造函数中下手//方案二:把非可选改成可选//方案三:把非可选赋默认值let p = Person()class Person1:NSObject&#123;var name: String//若继承NSObject则必须重写构造方法override init()&#123;self.name = ""&#125;&#125; class Stu &#123;//属性 实例属性 类型属性//类型属性static var personCount :Int = 0//实例属性(存储属性,计算属性)//存储属性:可以直接用来存储数值的属性var name :String = ""var age :Int = 0var scoral :Double = 0var scoral2 :Double = 0//计算属性:并不是直接用来存储数值的,他是通过某写计算得来的数值var avgScoral :Double = &#123;get&#123;return (scoral+scoral2)/2&#125;&#125;init()&#123;Stu.personCount+=1&#125;deinit &#123;Stu.personCount-=1&#125;//实例方法func text() &#123;print("当前有\(Stu.personCount)人")&#125;//类方法//static修饰不能被重写static func PrintCount&#123;print("当前有\(Stu.personCount)人")&#125;&#125;var p :Stu? = Stu()var p1 :Stu? = Stu()var p2 :Stu? = Stu()Stu.personCountp = nilp1 = nilp2 = nilStu.personCount 析构函数class Stu: NSObject&#123;var name:String = ""var age:Int = 0// 析构函数 == OC 中的deallocdeinit &#123;print("对像被释放了")&#125;&#125;var s:Stu? = Stu()s = nil]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 枚举和结构体]]></title>
    <url>%2F2018%2F04%2F26%2FSwift-%E4%BA%94-%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[枚举 语法规范： 枚举类型第一个字母小写 enum Direction &#123;case eastcase westcase southcase north&#125;Direction.west// 或者enum Fangxiang &#123;case east, west, south, north&#125; 给枚举赋值 Swift中，枚举默认情况下，不表示任何类型就是一个标识 枚举类型可以是字符串/字符/整形/浮点型 enum Direction: Int &#123; //赋值类型，必须给枚举写类型case east = 2case west = 3case south = 4case north = 5&#125;// rawValue 代表的是一个枚举对应的原始值// 枚举值 -&gt; 原始值var rv = Direction.east.rawValue//原始值 -&gt; 枚举值let z = Direction(rawValue: 4)//枚举值绑定字符串enum Path: String &#123;case cache = "cache"case docment = "documnet"&#125;print(Path.cache.rawValue) 结构体1、结构体概念 结构体是由一系列有相同类型或者不同类型的数据构成的数据集合结构体指是一种数据结构结构体是值类型，在方法中传递时是指传递 2、结构体格式 struct 结构体名称{属性和方法}无论是枚举还是结构体都可以写方法类型方法：static func 实例方法：func (区别：参考OC中的类方法和实例方法，类调用和类对象调用)类型属性 实例属性 (区别：参考OC中的类属性和实例属性，类调用和类对象调用 struct Point &#123;//实例属性var x: Doublevar y: Double//实例方法func distance() &#123;print("距离",x,y)&#125;// 类型属性static var z: Double = 0static func dis () &#123;print("xxx",z)&#125;&#125;// 类属性，类方法的调用Point.z = 1Point.dis()// 实例属性，实例方法的调用var p = Point(x: 1,y: 2)p.distance()p.x = 3p.distance() 3、结构体的扩充函数 默认情况下，结构体会自动创建一个“琢一构造器”—&gt;目的就是让所有”非可选成员”都能有值扩充构造函数 struct Point &#123;//非可选，永远不会为nilvar x: Doublevar y: Doublevar z: Double?//自定义函数 != 普通函数//必须使用init 作为名称// 在构造函数内部，必须保证，所有的非可选熟悉感，必须有值// 如果我们现在自定定义的构造函数，那么系统自动生成的琢一构造器就没有了init(x: Double, y: Double) &#123;self.x = xself.y = y&#125;init(x: Double, y: Double, z: Double) &#123;self.x = xself.y = yself.z = z&#125;&#125;//我们直接使用时系统提供的"构造函数"=="构造实例函数"//let p = Point(x:1,y:2)//p.z = nillet p = Point(x: 1, y: 2)let p1 = Point(x: 1, y: 2, z: 3)// 系统默认生成的构造函数→"逐一构造器"// 逐个给里面所有的非可选属性赋值,目的,就是为了保证当一个实例创建好之后,里面所有的非可选属性,都有值]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 类型转换和空和运算符]]></title>
    <url>%2F2018%2F04%2F26%2FSwift-%E5%9B%9B-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%A9%BA%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[可选类型 什么是可选类型呢?一个变量要么有值,要么没有值。 那么为什么产生可选类型呢?比如在OC中基本数据如果不赋值都会存在默认值,所以不会产生没有值得情况,但是没有值和默认值是完全不同的两个概念所以Swift中引入了”可选类型的概念”,来区分有值和没有值两种情况 1、可选类型 可选类型也是一种类型，代表可能有值，也可能没有值swift中nil,不同于oc中的nil,oc中的nil为一个特殊的地址，swift中nil就是一个特殊含义的字符，表示没有值只有可选类型才能被赋值为nil非可选类型无论在哪里，什么时候都有值 var num: Int? = 1 2、强制解包（取出可选类型里面的值）var num: Int? = 0if num != nil &#123;num!&#125;if let a = num &#123;a&#125;func check(score: Int?) &#123;guard let s = score else &#123;print("111")&#125;&#125;check(score: num) 1、类型转换符号 is：用于判断一个实例是否是某种类型 var a: Int = 0a is Int as： 净实例转换成某一种类型as? :将某个类型转换成可选类型，通过判断某个可选类型是否有值，来决定是否转换成功（as? 代表系统尝试帮你进行转换，转失败了，值就是nil）as! :将某个类型转成具体类型，但是如果不是该类型，程序就会崩溃 （as! 代表肯定可以转换成功，转换结果是非可选的，不能为nil） 2、空和运算符空和运算符使用两个问好来表示（a ?? b）对a 进行是否为nil的判断，如果a不是nil,那么久返还 a!,否则返回b (所以，a 必须是一个可选类型，同时 b 的值类型也要和 a 一样) 空和： 是对于三目运算符来某个值是否为nil的简写 a! == nil ? a! :b 三目a ?? b 空和]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 字符串]]></title>
    <url>%2F2018%2F04%2F26%2FSwift-%E4%BA%8C-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1、字符串的基本使用OC与Swift字符串的区别 OC 中使用字符串类型是NSSting,Swift 中使用的字符串类型是StringOC中使用的是@“”，Swift用在“”使用String的原因String是一个结构体，性能更高（保存的是直接的值）NSString是OC的一个对象，性能略差String支持遍历 常见使用 var str = "傲慢与偏见"//获取字符串的长度str.lengthOfBytes(using:String.Encoding.utf8)//获取字节长度str.count//获取字符串长度//字符串遍历for c in str &#123;print(c)&#125;//字符串拼接str + "愚蠢" 未完待续]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 逻辑分支和循环]]></title>
    <url>%2F2018%2F04%2F26%2FSwift-%E4%B8%80-%E9%80%BB%E8%BE%91%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[1. guard 语句 guard 是swift2.0新增语法 guard语句必须带有else语句，语法如下 当条件表达式为true时，跳过else语句中的内容，执行语句组内容 当条件表达式为false时，执行else语句内容，跳转语句一般是reture,break,continue,throw //如果一个成年人带了省份证才能上网func cherk(age:Int hasCard:Bool)&#123;if age &gt;= 18&#123;if hasCard&#123;print("老板,开个机")&#125;else&#123;print("回家拿身份证")&#125;else&#123;print("未成年不能上网")&#125;&#125;func cherkGuard(age:Int hasCard:Bool)&#123;guard age &gt;= 18 else &#123;print("老板,开个机")return&#125;guard hasCard else &#123;print("回家拿省份证")return&#125;print("未成年不能上网")&#125; 2、switch的基本使用OC中 switch后面必须加（） case后面只能加一个条件 case会有穿透效果 可以不写default default位置可以随便放 case中定义变量需要加大括号，否则作用域会混乱 不能判断对象或者浮点型类型，只能判断整数 Swift switch后面可以不加（） case后面能跟多个条件用逗号隔开 case不会有穿透效果，要穿透需要在后面加fallthrough 不可以不写default,位置也必须放在最后 case中定义变量不需要加大括号 能判断对象或浮点型，整数 元祖匹配 let point = (10,15)switch point &#123;case (0,0):print("在坐标原点")case (1...10,1...10):print("在1...10之间")case (10,15):print("在X轴上")default:print("其他")&#125; 值绑定 switch point &#123;case (var x,0):print("x=\(x)")case (10,var y):print("y=\(y)")case var(x,y):print("x=\(x) y=\(y)")default:print("其他")&#125; 根据条件绑定 let po = (100,10)switch po &#123;case var(x,y) where x &gt; y:print("x=\(x) y=\(y)")default:print("其他")&#125; 3、区间匹配 区间匹配 概念：通常描述的是数字区间分为闭区间和半开半闭区间 0...10//闭区间代表区域在0~100..&lt;10//半开半闭区间代表区域在0~、 区间操作 交集：clamped 是否重叠：overipas 判断包含：contains 是否为空: isEmpty 4、for循环for var x in 0..&lt;10 &#123;print(x)&#125; 5、while循环和do while循环while i &gt; 0 &#123;i -= 1print(i)&#125;//do while 循环 swift中不用do ,do 在swift转给你有特殊含义，用于捕捉异常repeat&#123;i += 1print(i)&#125;while i &lt; 10]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath]]></title>
    <url>%2F2018%2F04%2F26%2FUIBezierPath%2F</url>
    <content type="text"><![CDATA[UIBezierPath 看了前面，大家是不是都想来看看UIBezierPath详解呢，然后开始展示真正的装逼技术撒，其实，看完你就会发现UIBezierPath也就那么回事（先泼一盆冷水） 创建UIBezierPath的类方法介绍 初始化 + (instancetype) bezierPath; 初始化矩形 /*** 该方法将会创建一个闭合路径, 起始点是 rect 参数的的 origin, 并且按照顺时针方向添加直线, 最终形成矩形* @param rect: 矩形路径的 Frame*/+ (instancetype)bezierPathWithRect:(CGRect)rect; 椭圆形 /*** 该方法将会创建一个闭合路径, 该方法会通过顺时针的绘制贝塞尔曲线, 绘制出一个近似椭圆的形状. 如果 rect 参数指定了一个矩形, 那么该 UIBezierPath 对象将会描述一个圆形.* @param rect: 矩形路径的 Frame*/+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; 圆角矩形 /*** 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线. 当 rect 为正方形时且 cornerRadius 等于边长一半时, 则该方法会描述一个圆形路径.* @param rect: 矩形路径的 Frame* @param cornerRadius: 矩形的圆角半径*/+ (instancetype) bezierPathWithRoundedRect:(CGRect)rectcornerRadius:(CGFloat)cornerRadius; 特定的圆角矩形 /*** 该方法将会创建一个闭合路径, 该方法会顺时针方向连续绘制直线和曲线.* @param rect: 矩形路径的 Frame* @param corners: UIRectCorner 枚举类型, 指定矩形的个角变为圆角* @param cornerRadii: 矩形的圆角半径*/+ (instancetype) bezierPathWithRoundedRect:(CGRect)rectbyRoundingCorners:(UIRectCorner)cornerscornerRadii:(CGSize)cornerRadii; 弧度 /*** 该方法会创建出一个开放路径, 创建出来的圆弧是圆的一部分. 在默认的坐标系统中, 开始角度 和 结束角度 都是基于单位圆的(看下面这张图). 调用这个方法之后, currentPoint 将会设置为圆弧的结束点.* 举例来说: 指定其实角度为0, 指定结束角度为π, 设置 clockwise 属性为 YES, 将会绘制出圆的下半部分.* 然而当我们不修改起始角度 和 结束角度, 我们仅仅将 clockwise 角度设置为 NO, 则会绘制出来一个圆的上半部分.* @param center: 圆心* @param radius: 半径* @param startAngle: 起始角度* @param endAngle: 结束角度* @param clockwise: 是否顺时针绘制 Yes顺，NO逆时针*/+ (instancetype) bezierPathWithArcCenter:(CGPoint)centerradius:(CGFloat)radiusstartAngle:(CGFloat)startAngleendAngle:(CGFloat)endAngleclockwise:(BOOL)clockwise; 根据具体路径返回形状+ (instancetype) bezierPathWithCGPath:(CGPathRef)CGPath; 修改绘制方向 /*** 通过该方法反转一条路径, 并不会修改该路径的样子. 它仅仅是修改了绘制的方向* @return: 返回一个新的 UIBezierPath 对象, 形状和原来路径的形状一样,* 但是绘制的方向相反.*/- (UIBezierPath *) bezierPathByReversingPath; 开始点（将currentPoint移动到指定的点） // 将开始描绘的点移动到某一点- (void)moveToPoint:(CGPoint)point; 添加直线 /*** 该方法将会从 currentPoint 到 指定点 链接一条直线.* Note: 在追加完这条直线后, 该方法将会更新 currentPoint 为 指定点* 调用该方法之前, 你必须先设置 currentPoint. 如果当前绘制路径* 为空, 并且未设置 currentPoint, 那么调用该方法将不会产生任何* 效果.* @param point: 绘制直线的终点坐标, 当前坐标系统中的某一点*/- (void)addLineToPoint:(CGPoint)point; 添加弧线 /** * 该方法将会从 currentPoint 添加一条指定的圆弧. * 该方法的介绍和构造方法中的一样. 请前往上文查看 * @param center: 圆心 * @param radius: 半径 * @param startAngle: 起始角度 * @param endAngle: 结束角度 * @param clockwise: 是否顺时针绘制 */ (void)addArcWithCenter:(CGPoint)center radius:\(CGFloat\)radiusstartAngle:\(CGFloat\)startAngleendAngle:\(CGFloat\)endAngleclockwise:\(BOOL\)clockwise NS\_AVAILABLE\_IOS\(4\_0\); 添加一条三次贝塞尔曲线 /*** 该方法将会从 currentPoint 到 指定的 endPoint 追加一条三次贝塞尔曲线.* 三次贝塞尔曲线的弯曲由两个控制点来控制. 如下图所示* Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空,* 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果.* 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为* 指定的结束点* @param endPoint: 终点* @param controlPoint1: 控制点1* @param controlPoint2: 控制点2*/- (void)addCurveToPoint:(CGPoint)endPointcontrolPoint1:(CGPoint)controlPoint1controlPoint2:(CGPoint)controlPoint2; 添加一条二次贝塞尔曲线 /*** 该方法将会从 currentPoint 到 指定的 endPoint 追加一条二次贝塞尔曲线.* currentPoint、endPoint、controlPoint 三者的关系最终定义了二次贝塞尔曲线的形状.* 二次贝塞尔曲线的弯曲由一个控制点来控制. 如下图所示* Note: 调用该方法前, 你必须先设置 currentPoint, 如果路径为空,* 并且尚未设置 currentPoint, 调用该方法则不会产生任何效果.* 当添加完贝塞尔曲线后, 该方法将会自动更新 currentPoint 为* 指定的结束点* @param endPoint: 终点* @param controlPoint: 控制点*/- (void)addQuadCurveToPoint:(CGPoint)endPointcontrolPoint:(CGPoint)controlPoint; 关闭子路径（连接一条线到起点） /*** 该方法将会从 currentPoint 到子路经的起点 绘制一条直线,* 以此来关闭当前的自路径. 紧接着该方法将会更新 currentPoint* 为 刚添加的这条直线的终点, 也就是当前子路经的起点.*/- (void)closePath; 删除所有路径（点） - (void)removeAllPoints; 将指定的UIBezierPath中的内容添加到当前UIBezierPath中 /*** 该方法将会在当前 UIBezierPath 对象的路径中追加* 指定的 UIBezierPath 对象中的内容.*/- (void)appendPath:(UIBezierPath *)bezierPath; 绘图属性 线宽 /** 线宽属性定义了 UIBezierPath 对象中绘制的曲线规格. 默认为: 1.0*/@property(nonatomic) CGFloat lineWidth; 曲线终点样式 /*** 该属性应用于曲线的终点和起点. 该属性在一个闭合子路经中是无效果的. 默认为: kCGLineCapButt*/@property(nonatomic) CGLineCap lineCapStyle;// CGPath.h/* Line cap styles. */typedef CF_ENUM(int32_t, CGLineCap) &#123;kCGLineCapButt,kCGLineCapRound,kCGLineCapSquare&#125;; 曲线连接样式 /*** 默认为: kCGLineJoinMiter.*/@property(nonatomic) CGLineJoin lineJoinStyle;// CGPath.h/* Line join styles. */typedef CF_ENUM(int32_t, CGLineJoin) &#123;kCGLineJoinMiter,kCGLineJoinRound,kCGLineJoinBevel&#125;; 内角和外角的距离 /*** 两条线交汇处内角和外角之间的最大距离, 只有当连接点样式为 kCGLineJoinMiter* 时才会生效，最大限制为10* 我们都知道, 两条直线相交时, 夹角越小, 斜接长度就越大.* 该属性就是用来控制最大斜接长度的.* 当我们设置了该属性, 如果斜接长度超过我们设置的范围,* 则连接处将会以 kCGLineJoinBevel 连接类型进行显示.*/@property(nonatomic) CGFloat miterLimit; 渲染精度 /*** 该属性用来确定渲染曲线路径的精确度.* 该属性的值用来测量真实曲线的点和渲染曲线的点的最大允许距离.* 值越小, 渲染精度越高, 会产生相对更平滑的曲线, 但是需要花费更* 多的计算时间. 值越大导致则会降低渲染精度, 这会使得渲染的更迅* 速. flatness 的默认值为 0.6.* Note: 大多数情况下, 我们都不需要修改这个属性的值. 然而当我们* 希望以最小的消耗去绘制一个临时的曲线时, 我们也许会临时增* 大这个值, 来获得更快的渲染速度.*/@property(nonatomic) CGFloat flatness; 虚线 /*** @param pattern: 该属性是一个 C 语言的数组, 其中每一个元素都是 CGFloat* 数组中的元素代表着线段每一部分的长度, 第一个元素代表线段的第一条线,* 第二个元素代表线段中的第一个间隙. 这个数组中的值是轮流的. 来解释一下* 什么叫轮流的.* 举个例子: 声明一个数组 CGFloat dash[] = @&#123;3.0, 1.0&#125;;* 这意味着绘制的虚线的第一部分长度为3.0, 第一个间隙长度为1.0, 虚线的* 第二部分长度为3.0, 第二个间隙长度为1.0. 以此类推.* @param count: 这个参数是 pattern 数组的个数* @param phase: 这个参数代表着, 虚线从哪里开始绘制.* 举个例子: 这是 phase 为 6. pattern[] = @&#123;5, 2, 3, 2&#125;; 那么虚线将会* 第一个间隙的中间部分开始绘制, 如果不是很明白就请继续往下看,* 下文实战部分会对虚线进行讲解.*/- (void)setLineDash:(const CGFloat *)patterncount:(NSInteger)countphase:(CGFloat)phase; 重新获取虚线样式 /*** 该方法可以重新获取之前设置过的虚线样式.* Note: pattern 这个参数的容量必须大于该方法返回数组的容量.* 如果无法确定数组的容量, 那么可以调用两次该方法, 第一次* 调用该方法的时候, 传入 count 参数, 然后在用 count 参数* 来申请 pattern 数组的内存空间. 然后再第二次正常的调用该方法*/- (void)getLineDash:(CGFloat *)patterncount:(NSInteger *)countphase:(CGFloat *)phase; 绘制路径 填充 /*** 该方法当前的填充颜色 和 绘图属性对路径的封闭区域进行填充.* 如果当前路径是一条开放路径, 该方法将会隐式的将路径进行关闭后进行填充* 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要* 自己手动的去保存绘图状态了.*/- (void)fill; 描边 - (void)stroke; 混合 /*** 该方法当前的填充颜色 和 绘图属性 (外加指定的混合模式 和 透明度)* 对路径的封闭区域进行填充. 如果当前路径是一条开放路径, 该方法将* 会隐式的将路径进行关闭后进行填充* 该方法在进行填充操作之前, 会自动保存当前绘图的状态, 所以我们不需要* 自己手动的去保存绘图状态了.** @param blendMode: 混合模式决定了如何和已经存在的被渲染过的内容进行合成* @param alpha: 填充路径时的透明度*/- (void)fillWithBlendMode:(CGBlendMode)blendModealpha:(CGFloat)alpha;- (void)strokeWithBlendMode:(CGBlendMode)blendModealpha:(CGFloat)alpha; 路径剪切/*** 该方法将会修改当前绘图上下文的可视区域.* 当调用这个方法之后, 会导致接下来所有的渲染* 操作, 只会在剪切下来的区域内进行, 区域外的* 内容将不会被渲染.* 如果你希望执行接下来的绘图时, 删除剪切区域,* 那么你必须在调用该方法前, 先使用 CGContextSaveGState 方法* 保存当前的绘图状态, 当你不再需要这个剪切区域* 的时候, 你只需要使用 CGContextRestoreGState 方法* 来恢复之前保存的绘图状态就可以了.*/- (void)addClip; 一些判断 是否包含某个点 /*** 该方法返回一个布尔值, 当曲线的覆盖区域包含* 指定的点(内部点)， 则返回 YES, 否则返回 NO.* Note: 如果当前的路径是一个开放的路径, 那么* 就算指定点在路径覆盖范围内, 该方法仍然会* 返回 NO, 所以如果你想判断一个点是否在一个* 开放路径的范围内时, 你需要先Copy一份路径,* 并调用 -(void)closePath; 将路径封闭, 然后* 再调用此方法来判断指定点是否是内部点.* @param point: 指定点.*/- (BOOL) containsPoint:(CGPoint)point; 路径是否为空 /*** 检测当前路径是否绘制过直线或曲线.* Note: 记住, 就算你仅仅调用了 moveToPoint 方法* 那么当前路径也被看做不为空.*/@property (readonly, getter=isEmpty) BOOL empty; 路径覆盖的矩形区域 /*** 该属性描述的是一个能够完全包含路径中所有点* 的一个最小的矩形区域. 该区域包含二次贝塞尔* 曲线和三次贝塞尔曲线的控制点.*/ 放射变换/*** 该方法将会直接对路径中的所有点进行指定的放射* 变换操作.*/- (void)applyTransform:(CGAffineTransform)transform; 画个虚线UIBezierPath *path =[UIBezierPath bezierPath];[path moveToPoint:CGPointMake(10, 50)];[path addLineToPoint:CGPointMake(300, 50)];path.lineWidth = 2;[[UIColor redColor] set];UIBezierPath *path1 =[UIBezierPath bezierPath];[path1 moveToPoint:CGPointMake(10, 100)];[path1 addLineToPoint:CGPointMake(300, 100)];path1.lineWidth = 2;UIBezierPath *path2 =[UIBezierPath bezierPath];[path2 moveToPoint:CGPointMake(10, 150)];[path2 addLineToPoint:CGPointMake(300, 150)];path2.lineWidth = 2;CGFloat dash[] = &#123;20.0,10.0&#125;;CGFloat dash1[] = &#123;20.0,10.0,40.0,20.0&#125;;CGFloat dash2[] = &#123;30.0,10.0&#125;;[path setLineDash:dash count:2 phase:0];// 注意这里如果是三那个只会用到20，10，40，后面的20用不到[path1 setLineDash:dash1 count:3 phase:0];[path2 setLineDash:dash2 count:2 phase:2];[path stroke];[path1 stroke];[path2 stroke];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[画图基本操作]]></title>
    <url>%2F2018%2F04%2F26%2F%E7%94%BB%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言应该是没有前言的，但是，尼玛，写了一上午的画图。第二天起来一看全没了，不得不吐槽下Gitbook，又得重复劳动………… 以下操作在均在自定义View的drawRect方法中 画线条 获取上下文（在drawRect方法中系统已经帮我们创建好一个跟View相关联的上下文了，我们直接获取就行，其他的我们还要自己开启和关闭） CGContextRef ctx = UIGraphicsGetCurrentContext(); 绘制路径 UIBezierPath *path = [UIBezierPath bezierPath];//设置起点[path moveToPoint:CGPointMake(50, 200)];//添加一条线的终点[path addLineToPoint:CGPointMake(280, 50)];//画第二条线[path moveToPoint:CGPointMake(100, 200)];[path addLineToPoint:CGPointMake(250, 100)];//把上一条线的终点当做下一天线的起点[path addLineToPoint:CGPointMake(200, 200)]; 如果我们想对线条做一些操作，可以用以下这几种方式 &gt; //上下文的状态(线宽颜色)&gt; CGContextSetLineWidth(ctx, 10);&gt; //线的交点样式&gt; CGContextSetLineJoin(ctx, kCGLineJoinRound);&gt; //线的两头样式&gt; CGContextSetLineCap(ctx, kCGLineCapRound);&gt; //设置颜色(要和下文渲染和填充用一样的)&gt; //[[UIColor redColor] setStroke];&gt; //一般用这个设置颜色&gt; [[UIColor redColor] set];&gt; 把绘制内容添加到上下文中 // CGPathRef:CoreGraphics框架下的// UIBezierPath:UIKit框架下的CGContextAddPath(ctx, path.CGPath); 把上下文的内容显示到View上（渲染到View的Layer上，有两种渲染方式stroke描边和 fill填充） CGContextStrokePath(ctx); 如果我们想要在一个View上画出不同的线条该怎么操作呢,其实有个上下文状态站可以为我们解决（可以保存多个和取出多个）&gt; CGContextSaveGState(ctx);//保存&gt; CGContextRestoreGState(ctx);//取出&gt; //1.获取上下文CGContextRef ctx = UIGraphicsGetCurrentContext();//2.描述路径UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(20, 150)];[path addLineToPoint:CGPointMake(280, 150)];//3.把路径添加到上下文当中.CGContextAddPath(ctx, path.CGPath);//保存当前上下文的状态(第一次保存)CGContextSaveGState(ctx);//设置上下文的状态CGContextSetLineWidth(ctx, 10);[[UIColor redColor] set];//保存当前上下文的状态(第二次保存)CGContextSaveGState(ctx);//4.把上下文当中的内容渲染ViewCGContextStrokePath(ctx);UIBezierPath *path2 = [UIBezierPath bezierPath];[path2 moveToPoint:CGPointMake(150, 20)];[path2 addLineToPoint:CGPointMake(150, 280)];//把路径添加到上下文当中.CGContextAddPath(ctx, path2.CGPath);//从上下文状态栈当中恢复上下文的状态（取出保存两次的）CGContextRestoreGState(ctx);CGContextRestoreGState(ctx);//把上下文当中的内容渲染ViewCGContextStrokePath(ctx); 画曲线CGContextRef ctx = UIGraphicsGetCurrentContext();UIBezierPath *path = [UIBezierPath bezierPath];[path moveToPoint:CGPointMake(50, 280)];[path addQuadCurveToPoint:CGPointMake(250, 280) controlPoint:CGPointMake(50, 50)];CGContextAddPath(ctx, path.CGPath);CGContextStrokePath(ctx); 画矩形CGContextRef ctx = UIGraphicsGetCurrentContext();[[UIColor redColor] set];//矩形// UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 100, 180)];//圆角矩形UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 180, 100) cornerRadius:50];CGContextAddPath(ctx, path.CGPath);// CGContextStrokePath(ctx);CGContextFillPath(ctx); 画椭圆 （快速画图)//椭圆UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 50, 100, 50)];//使用UIBezier提佛那个的绘图方法// [path fill];//只有在drawRect方法中才可以，因为默认调用了下面的获取上下门的方法[path stroke]; 画弧//画弧//center 弧所在的圆心//园的半径//开始角度 最右侧开始 可以为-数//截止角度//YES 顺时针 NO逆时针CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5);UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:50 startAngle:0 endAngle:-M_PI_2 clockwise:NO];//添加一条线到圆心[path addLineToPoint:center];//关闭路径closePath: 从路径重点连接一根线到路径的起点[path closePath];[path stroke]; 小记：如果想主动调用drawRect：方法可以调用View的setNeedsDisplay方法 画大饼 //画第一个扇形CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5);CGFloat radius = rect.size.width * 0.5 - 40 ;CGFloat endA = 0.25 * M_PI * 2;UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle: 0 endAngle:endA clockwise:YES];[[UIColor redColor] set];[path addLineToPoint:center];[path fill];CGFloat endA2 = endA + (0.25 * M_PI * 2) ;UIBezierPath * path2 =[UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:endA endAngle:endA2 clockwise:YES];[[UIColor greenColor] set];[path2 addLineToPoint:center];[path2 fill];CGFloat endA3 = endA2 + (0.5 * M_PI * 2) ;UIBezierPath * path3 =[UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:endA2 endAngle:endA3 clockwise:YES];[[UIColor yellowColor] set];[path3 addLineToPoint:center];[path3 fill];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaunchImage启动页设置]]></title>
    <url>%2F2018%2F02%2F24%2FLaunchImage%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用Assets.xcassets中的launchImage设置启动图 如下图点击+新建 New Launch Image 然后根据需求选择是否要横屏和竖屏和版本选择 将 图片放入合适的位置，大小如下(单位px) 2X 640*960(4/4s)Retina4 640*1136(5/5s/5c)Retina4.7 750*1134(6/7)Retina5.5 1242*2208(6P/7p)iphoneX 1125*2436 打开LaunchScreen.storyboard 中取消Use as Launch Screen 的勾选 设置Launch Screen File]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件化开发准备 一]]></title>
    <url>%2F2018%2F02%2F07%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[如何将自己的项目发布到Cocoapods上具体分为以下四个步骤 1. 创建 .podspec 文件 2. 验证 github 仓库 3. 登录注册 cocoapods 4. 发布到 cocoapods 创建.podspec文件注册GitHub仓库由于cocoapods都托管在GitHub上，所有的pods也都依赖github,所以我们在创建.podspec文件之前，我们要现在我们的github上新建仓库 这里说明下add a license 这个选项，一般来说我们建立自己的仓库的时候一般不会勾选这个东西，但是正规仓库都应该有一个license文件。而且pods依赖库也对这个文件要求更严，所以必须要有，这里我们选择MIT类型 执行 git clone 到本地我们在本地新建一个文件夹，比如我在桌面上建立pods文件夹,然后在终端cd到我们的文件夹执行下载命令git clone https://github.com/Smalldevelopment/JJPods.git 然后我们在该目录下放入我们要上传的文件，如下图 创建.podspec文件cd到pods/JJpods，在pods/JJpods文件夹在执行 pod spec create JTest 执行后pods/JJPods文件夹下回创建JTest.podspec文件然后打开它，如果用自带的文本打开它可能会出现单双引号问题，这里我们用sublime Test 来打开它，然后直接修改吧，不想一个个修改就直接粘贴复制吧 Pod::Spec.new do |s| s.name = "JJPods" s.version = "1.0.0" s.summary = "a test" s.description = "A test" s.homepage = "https://github.com/Smalldevelopment/JJPods.git" s.social_media_url = "https://github.com/Smalldevelopment/JJPods.git" s.license= &#123; :type =&gt; "MIT", :file =&gt; "LICENSE" &#125; s.author = &#123; "JJ" =&gt; "you@163.com" &#125; s.source = &#123; :git =&gt; "https://github.com/Smalldevelopment/JJPods.git", :tag =&gt; s.version &#125; s.source_files = "JTest/*.&#123;h,m&#125;" s.ios.deployment_target = '6.0' s.frameworks = 'UIKit' s.requires_arc = trueend 修改后，我们来本地验证下,在终端执行pod lib lint 如果正确会这样显示 如果出现错误，按照提示修改下错误后天我们再把代码上传到github上，注意这里我们上传要打一个taggit tag 1.0.0 这里的1.0.0就是我们在podspec中填写的版本号,然后我们在验证远程仓库中的podspec文件是否正确，因为上传到cocoapods最终验证的还是我们github上的文件pod spec lint]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置教程]]></title>
    <url>%2F2018%2F02%2F07%2Fhexo%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网站的配置文件1. 主要是修改/_config.yml文件里面的东西 2. 配置文件中，冒号后面一定要加空格# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site#标题title: 一个被怼的小开发 #副标题subtitle: 我就看你皮#网站描述description: 我就看你皮#作者昵称author: 一个被怼的小开发#网站语言，默认英语，设置简体汉语language: zh-Hans#时区，默认电脑时区timezone:# 网址设置#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'#网址 url: http://yoursite.com#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。permalink_defaults: # Directory#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tags#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,放在[]中# 这里我实在source下面建立ori_data文件夹，存放原始.md文件，上传git管理skip_render: [README.md, ori_data/*, ori_data/posts/*, ori_data/tags/*, ori_data/categories/*, ori_data/themes/next/*] # 禁止进行渲染的文件# Writing# 新建博文（帖子）的默认名称new_post_name: :title.md # File name of new posts#默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true # 使用代码高亮 line_number: false # 显示行号 auto_detect: true # 自动检测语言 tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' #每页显示的文章量 per_page: 10 order_by: -date # Category &amp; Tag# 分类和标签# 默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/# 日期和时间格式#Hexo 使用 Moment.js 来解析和显示时间。date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10#分页路径，在public中可以看到pagination_dir: page# Extensions# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# 主题配置theme: next# Deployment# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:Smalldevelopment/Smalldevelopment.github.io.git,master ## coding: git@git.coding.net:ookamiantd/ookamiantd.git,master]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何搭建这样的博客]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo + Node.js +github +coding 搭建自己的博客首先先看完成后的效果图吧。 先来说说hexo搭建博客的大致流程吧 首先安装Node.js–&gt;安装Git–&gt;安装Hexo–&gt;安装主题–&gt;本地测试运行–&gt;配置github和coding仓库–&gt;上传部署 安装Node.js和npm直接访问node.js官网(https://nodejs.org/en/),如下图直接点击安装 下载完成之后直接点击进行安装，安装之后查看是否安装成功 node -versionnpm -version 安装Gitsudo apt-get install git 安装Hexonpm install -g hexo-cli 如果顺利安装完成，理论上Hexo已经安装完成，但在Ubuntu系统中，比较坑的地方就是 hexo 命令居然放在了Node.js安装目录的 bin 文件夹下，不能快捷地在终端把命令敲出来，所以还是老规矩，软链接走起 sudo ln -s /home/ybd/data/application/node-v7.4.0-linux-x64/bin/hexo /usr/local/bin/hexo 现在hexo基本安装完成了，下面我们本地启动看看样式 首先初始化在桌面随便创建文件夹，然后在终端cd到文件夹，执行以下命令 hexo init # hexo 会在目标文件夹简历网站所需要的文件npm install # 安装依赖包 本地启动 通过以下命令来在本地运行我们的博客 hexo g # 相当于 hexo generate，生成静态文件hexo s # 相当于 hexo server，在本地服务器上运行 复制以上本地地址http://localhost:4000/在浏览器中打开 基本就是这样的，是不是觉得很丑，别急，后面我们会介绍一些主题 新建文章与页面hexo new "title" # 生成新文章：\source\_posts\title.mdhexo new page "title" # 生成新的页面，后面可在主题配置文件中配置页面,目录所在\source\title 生成文章或页面的末班放在博客文件夹跟目录下的scaffolds/文件夹下面,文章对应的是post.md,页面对应的是page.md，草稿对应的是draft.md编辑文章打开新建的文章\source\_posts\title.md,一般选择可以支持markdown格式的编辑器打开 title: Start My Blog Trip — Power By Hexo # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2017-01-10 23:49:28 # 文章生成时间，一般不改categories: diary # 文章分类目录，多个分类使用[a,b,c]这种格式tags: [Hexo,diary] # 文章标签---#这里开始使用markdown格式输入你的正文。&lt;!--more--&gt; #more标签以下的内容要点击“阅读全文”才能看见 以上就是hexo安装和编辑的内容了，下面正式介绍如何安装主题 安装主题这里我们选择安装NexT的主图，样式即为开头的图片安装主题只需要将主题下载下来然后拷贝到我们的博客文件夹下的themes目录下，然后修改下我们的站点配置文件(也就是博客目录下的_config.yml) cd 你博客的文件夹地址git clone https://github.com/iissnan/hexo-theme-next themes/next 配置站点文件，即打开博客目录下的_config.yml文件，然后找到theme字段，将它的值该为next theme:next 现在我们在来执行下 hexo g #生成静态页面 hexo s # 启动本地服务 完成之后我们打开本地连接接可以看到我们的博客了 下面我们在来配置下主题文件的参数大部分的设定都可以的NexT官方文档中可以看到,大家可以点进去看看 最后我们来介绍如何把博客部署到外网上去GitHUb首先创建GitHub和coding账号，相信码农都有,我们要做的就是创建新的仓库来管理我们的博客文件在创建 Repository name 时候，我们可以勾选README文件，名字格式必须为github用户名.github.io,如下图 Coding和创建GitHub类似不过名字格式改为coding用户名.coding.me，如下图 然后查看pages服务是否开启：点击项目–&gt;代码–&gt;Pages服务，如果没有开发直接点击开启，部署来源直接我这里选择的是master 配置SSH与Git其实就是绑定电脑和服务器的关系， 生成SSH Keyssh-keygen -t rsa -C 你邮箱名 填写上你自己的邮箱过后，之后一直点击回车键我们就可以在~/下生成.ssh文件夹，进去打开 id_rsa.pub，复制里面的key 添加SSH Key登录GitHub，点击右上角的头像–&gt;Settings –&gt; SSH nd GPG keys –&gt; New SSH key 。把公钥粘贴到key中，填好title并点击 Add SSH key 如下图 登录Coding,点击右上角头像选择账户–&gt; SSH公钥–&gt;输入key再点击 添加 如果你想验证的话可以分别输入以下命令ssh -T git@github.com 如果是第一季会提示是否continue,直接输入yes就会看到You’ve successfully authenticated, but GitHub does not provide shell access 。表示链接成功了 ssh -T git@git.coding.net 最后只要把我们的博客部署到GitHub与Coding上就行了首先我们先安装Git部署插件 npm install hexo-deployer-git --save 打开我们的站点配置文件，拉倒底部，修改部署配置 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:Smalldevelopment/Smalldevelopment.github.io.git,master coding: git@git.coding.net:Mybalance/Mybalance.coding.me.git,master 这里我们填写的是SHH访问仓库的链接 下面在终端执行下,就可以上传了，部署完成后可在浏览器输入 yourName.github.io 或者 yourName.coding.me 都可以浏览到一个属于自己的博客了 hexo cleanhexo ghexo d]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS常用跳转]]></title>
    <url>%2F2018%2F02%2F05%2FiOS%E5%B8%B8%E7%94%A8%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[打电话 直接跳转拨号界面 弹出拨号选择提示框(telprompt是私有方法上架可能会被禁止) 创建一个UIWebView来加载URL，拨完后能自动跳回原来应用(这里的webView千万不要设置尺寸，不然会挡住其他页面) [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://110"] options:@&#123;&#125; completionHandler:nil]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"telprompt://110"] options:@&#123;&#125; completionHandler:nil]; if (_webView == nil) &#123; _webView =[[UIWebView alloc] initWithFrame:CGRectZero]; &#125;[_webView loadRequest:[NSURLRequest requestWithURL:[NSURL URlWithString:@"tel//100"]]]; 发短信 直接跳到发短信界面，但是不能指定短信内容，而且不能自动回到原来应用 如果想指定短信内容可以使用MessageUI框架 //第一种[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"sms://110"] options:@&#123;&#125; completionHandler:nil]; //第二种导入头文件#import &lt;MessageUI/MessageUI.h&gt; MFMessageComposeViewControllerDelegate初始化代理MFMessageComposeViewController *messageVC =[[MFMessageComposeViewController alloc] init];//发送短信内容messageVC.body = @"你好？";//要发送的人messageVC.recipients = @[@"110",@"911"];//设置代理messageVC.messageComposeDelegate = self;[self presentViewController:messageVC animated:YES completion:nil]; // 当短信界面关闭的时候代用，发完后就会自动回到原应用- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result&#123;//关闭短信界面[controller dismissViewControllerAnimated:YES completion:nil];if (result == MessageComposeResultCancelled) &#123;&#125;else if (result == MessageComposeResultSent)&#123;&#125;else if (result == MessageComposeResultFailed)&#123;&#125;&#125; 发邮件 用苹果手机自带的邮件客户端，发送完邮件不会自动回到原应用 和上面发短信差不多 //第一种[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"mailto://110@qq.com"] options:@&#123;&#125; completionHandler:nil]; //第一种导入头文件#import &lt;MessageUI/MessageUI.h&gt; MFMessageComposeViewControllerDelegate//初始化代理MFMailComposeViewController *mailVC = [[MFMailComposeViewController alloc] init];//发送短信内容[mailVC setMessageBody:@"你好?" isHTML:YES];//要发送的人[mailVC setToRecipients:@[@"",@""]];//设置代理mailVC.messageComposeDelegate = self;[self presentViewController:mailVC animated:YES completion:nil]; - (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error&#123;//关闭邮件界面[controller dismissViewControllerAnimated:YES completion:nil];if (result == MFMailComposeResultCancelled) &#123; NSLog(@"取消发送");&#125; else if (result == MFMailComposeResultSent) &#123; NSLog(@"已经发出");&#125; else &#123;NSLog(@"发送失败");&#125;&#125; 跳转AppStore评分//你应用在AppStore上面的IDNSString *appid =@"456464646";NSString *str = [NSString stringWithFormat: @"itms-apps://itunes.apple.com/cn/app/id%@?mt=8", appid];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str] options:@&#123;&#125; completionHandler:nil];]]></content>
  </entry>
</search>
